// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Protocol.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Protocol_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Protocol_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Protocol_2eproto;
namespace Protocol {
class C2SChatRoom;
struct C2SChatRoomDefaultTypeInternal;
extern C2SChatRoomDefaultTypeInternal _C2SChatRoom_default_instance_;
class C2SEnterRoom;
struct C2SEnterRoomDefaultTypeInternal;
extern C2SEnterRoomDefaultTypeInternal _C2SEnterRoom_default_instance_;
class C2SLoginSuccess;
struct C2SLoginSuccessDefaultTypeInternal;
extern C2SLoginSuccessDefaultTypeInternal _C2SLoginSuccess_default_instance_;
class C2SMakeRoom;
struct C2SMakeRoomDefaultTypeInternal;
extern C2SMakeRoomDefaultTypeInternal _C2SMakeRoom_default_instance_;
class C2SQuitRoom;
struct C2SQuitRoomDefaultTypeInternal;
extern C2SQuitRoomDefaultTypeInternal _C2SQuitRoom_default_instance_;
class P_GameContent;
struct P_GameContentDefaultTypeInternal;
extern P_GameContentDefaultTypeInternal _P_GameContent_default_instance_;
class P_Player;
struct P_PlayerDefaultTypeInternal;
extern P_PlayerDefaultTypeInternal _P_Player_default_instance_;
class P_Room;
struct P_RoomDefaultTypeInternal;
extern P_RoomDefaultTypeInternal _P_Room_default_instance_;
class S2CBattleServerAddr;
struct S2CBattleServerAddrDefaultTypeInternal;
extern S2CBattleServerAddrDefaultTypeInternal _S2CBattleServerAddr_default_instance_;
class S2CChatRoom;
struct S2CChatRoomDefaultTypeInternal;
extern S2CChatRoomDefaultTypeInternal _S2CChatRoom_default_instance_;
class S2CEnterRoom;
struct S2CEnterRoomDefaultTypeInternal;
extern S2CEnterRoomDefaultTypeInternal _S2CEnterRoom_default_instance_;
class S2CRoomCreated;
struct S2CRoomCreatedDefaultTypeInternal;
extern S2CRoomCreatedDefaultTypeInternal _S2CRoomCreated_default_instance_;
class S2CRoomID;
struct S2CRoomIDDefaultTypeInternal;
extern S2CRoomIDDefaultTypeInternal _S2CRoomID_default_instance_;
class S2CRoomList;
struct S2CRoomListDefaultTypeInternal;
extern S2CRoomListDefaultTypeInternal _S2CRoomList_default_instance_;
class S2CWinner;
struct S2CWinnerDefaultTypeInternal;
extern S2CWinnerDefaultTypeInternal _S2CWinner_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::C2SChatRoom* Arena::CreateMaybeMessage<::Protocol::C2SChatRoom>(Arena*);
template<> ::Protocol::C2SEnterRoom* Arena::CreateMaybeMessage<::Protocol::C2SEnterRoom>(Arena*);
template<> ::Protocol::C2SLoginSuccess* Arena::CreateMaybeMessage<::Protocol::C2SLoginSuccess>(Arena*);
template<> ::Protocol::C2SMakeRoom* Arena::CreateMaybeMessage<::Protocol::C2SMakeRoom>(Arena*);
template<> ::Protocol::C2SQuitRoom* Arena::CreateMaybeMessage<::Protocol::C2SQuitRoom>(Arena*);
template<> ::Protocol::P_GameContent* Arena::CreateMaybeMessage<::Protocol::P_GameContent>(Arena*);
template<> ::Protocol::P_Player* Arena::CreateMaybeMessage<::Protocol::P_Player>(Arena*);
template<> ::Protocol::P_Room* Arena::CreateMaybeMessage<::Protocol::P_Room>(Arena*);
template<> ::Protocol::S2CBattleServerAddr* Arena::CreateMaybeMessage<::Protocol::S2CBattleServerAddr>(Arena*);
template<> ::Protocol::S2CChatRoom* Arena::CreateMaybeMessage<::Protocol::S2CChatRoom>(Arena*);
template<> ::Protocol::S2CEnterRoom* Arena::CreateMaybeMessage<::Protocol::S2CEnterRoom>(Arena*);
template<> ::Protocol::S2CRoomCreated* Arena::CreateMaybeMessage<::Protocol::S2CRoomCreated>(Arena*);
template<> ::Protocol::S2CRoomID* Arena::CreateMaybeMessage<::Protocol::S2CRoomID>(Arena*);
template<> ::Protocol::S2CRoomList* Arena::CreateMaybeMessage<::Protocol::S2CRoomList>(Arena*);
template<> ::Protocol::S2CWinner* Arena::CreateMaybeMessage<::Protocol::S2CWinner>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class P_Room final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.P_Room) */ {
 public:
  inline P_Room() : P_Room(nullptr) {}
  ~P_Room() override;
  explicit PROTOBUF_CONSTEXPR P_Room(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_Room(const P_Room& from);
  P_Room(P_Room&& from) noexcept
    : P_Room() {
    *this = ::std::move(from);
  }

  inline P_Room& operator=(const P_Room& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_Room& operator=(P_Room&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_Room& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_Room* internal_default_instance() {
    return reinterpret_cast<const P_Room*>(
               &_P_Room_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(P_Room& a, P_Room& b) {
    a.Swap(&b);
  }
  inline void Swap(P_Room* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_Room* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_Room* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_Room>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_Room& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_Room& from) {
    P_Room::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_Room* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.P_Room";
  }
  protected:
  explicit P_Room(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 2,
    kHostNameFieldNumber = 3,
    kRoomIDFieldNumber = 1,
    kNumPlayersFieldNumber = 4,
  };
  // string roomName = 2;
  void clear_roomname();
  const std::string& roomname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomname();
  PROTOBUF_NODISCARD std::string* release_roomname();
  void set_allocated_roomname(std::string* roomname);
  private:
  const std::string& _internal_roomname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomname(const std::string& value);
  std::string* _internal_mutable_roomname();
  public:

  // string hostName = 3;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // int32 roomID = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // int32 num_players = 4;
  void clear_num_players();
  int32_t num_players() const;
  void set_num_players(int32_t value);
  private:
  int32_t _internal_num_players() const;
  void _internal_set_num_players(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.P_Room)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    int32_t roomid_;
    int32_t num_players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class P_Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.P_Player) */ {
 public:
  inline P_Player() : P_Player(nullptr) {}
  ~P_Player() override;
  explicit PROTOBUF_CONSTEXPR P_Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_Player(const P_Player& from);
  P_Player(P_Player&& from) noexcept
    : P_Player() {
    *this = ::std::move(from);
  }

  inline P_Player& operator=(const P_Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_Player& operator=(P_Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_Player* internal_default_instance() {
    return reinterpret_cast<const P_Player*>(
               &_P_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(P_Player& a, P_Player& b) {
    a.Swap(&b);
  }
  inline void Swap(P_Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_Player& from) {
    P_Player::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.P_Player";
  }
  protected:
  explicit P_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
  };
  // string userName = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.P_Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S2CRoomList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S2CRoomList) */ {
 public:
  inline S2CRoomList() : S2CRoomList(nullptr) {}
  ~S2CRoomList() override;
  explicit PROTOBUF_CONSTEXPR S2CRoomList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S2CRoomList(const S2CRoomList& from);
  S2CRoomList(S2CRoomList&& from) noexcept
    : S2CRoomList() {
    *this = ::std::move(from);
  }

  inline S2CRoomList& operator=(const S2CRoomList& from) {
    CopyFrom(from);
    return *this;
  }
  inline S2CRoomList& operator=(S2CRoomList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S2CRoomList& default_instance() {
    return *internal_default_instance();
  }
  static inline const S2CRoomList* internal_default_instance() {
    return reinterpret_cast<const S2CRoomList*>(
               &_S2CRoomList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(S2CRoomList& a, S2CRoomList& b) {
    a.Swap(&b);
  }
  inline void Swap(S2CRoomList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S2CRoomList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S2CRoomList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S2CRoomList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S2CRoomList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S2CRoomList& from) {
    S2CRoomList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S2CRoomList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S2CRoomList";
  }
  protected:
  explicit S2CRoomList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomsFieldNumber = 1,
  };
  // repeated .Protocol.P_Room rooms = 1;
  int rooms_size() const;
  private:
  int _internal_rooms_size() const;
  public:
  void clear_rooms();
  ::Protocol::P_Room* mutable_rooms(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::P_Room >*
      mutable_rooms();
  private:
  const ::Protocol::P_Room& _internal_rooms(int index) const;
  ::Protocol::P_Room* _internal_add_rooms();
  public:
  const ::Protocol::P_Room& rooms(int index) const;
  ::Protocol::P_Room* add_rooms();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::P_Room >&
      rooms() const;

  // @@protoc_insertion_point(class_scope:Protocol.S2CRoomList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::P_Room > rooms_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C2SMakeRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C2SMakeRoom) */ {
 public:
  inline C2SMakeRoom() : C2SMakeRoom(nullptr) {}
  ~C2SMakeRoom() override;
  explicit PROTOBUF_CONSTEXPR C2SMakeRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C2SMakeRoom(const C2SMakeRoom& from);
  C2SMakeRoom(C2SMakeRoom&& from) noexcept
    : C2SMakeRoom() {
    *this = ::std::move(from);
  }

  inline C2SMakeRoom& operator=(const C2SMakeRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline C2SMakeRoom& operator=(C2SMakeRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C2SMakeRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const C2SMakeRoom* internal_default_instance() {
    return reinterpret_cast<const C2SMakeRoom*>(
               &_C2SMakeRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(C2SMakeRoom& a, C2SMakeRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(C2SMakeRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C2SMakeRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C2SMakeRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C2SMakeRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C2SMakeRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C2SMakeRoom& from) {
    C2SMakeRoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C2SMakeRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C2SMakeRoom";
  }
  protected:
  explicit C2SMakeRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 1,
    kHostNameFieldNumber = 2,
    kNumPlayersFieldNumber = 3,
  };
  // string roomName = 1;
  void clear_roomname();
  const std::string& roomname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomname();
  PROTOBUF_NODISCARD std::string* release_roomname();
  void set_allocated_roomname(std::string* roomname);
  private:
  const std::string& _internal_roomname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomname(const std::string& value);
  std::string* _internal_mutable_roomname();
  public:

  // string hostName = 2;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // int32 num_players = 3;
  void clear_num_players();
  int32_t num_players() const;
  void set_num_players(int32_t value);
  private:
  int32_t _internal_num_players() const;
  void _internal_set_num_players(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C2SMakeRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomname_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
    int32_t num_players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C2SEnterRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C2SEnterRoom) */ {
 public:
  inline C2SEnterRoom() : C2SEnterRoom(nullptr) {}
  ~C2SEnterRoom() override;
  explicit PROTOBUF_CONSTEXPR C2SEnterRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C2SEnterRoom(const C2SEnterRoom& from);
  C2SEnterRoom(C2SEnterRoom&& from) noexcept
    : C2SEnterRoom() {
    *this = ::std::move(from);
  }

  inline C2SEnterRoom& operator=(const C2SEnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline C2SEnterRoom& operator=(C2SEnterRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C2SEnterRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const C2SEnterRoom* internal_default_instance() {
    return reinterpret_cast<const C2SEnterRoom*>(
               &_C2SEnterRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(C2SEnterRoom& a, C2SEnterRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(C2SEnterRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C2SEnterRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C2SEnterRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C2SEnterRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C2SEnterRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C2SEnterRoom& from) {
    C2SEnterRoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C2SEnterRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C2SEnterRoom";
  }
  protected:
  explicit C2SEnterRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIDFieldNumber = 1,
    kUserIDFieldNumber = 2,
  };
  // int32 roomID = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // int32 userID = 2;
  void clear_userid();
  int32_t userid() const;
  void set_userid(int32_t value);
  private:
  int32_t _internal_userid() const;
  void _internal_set_userid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C2SEnterRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    int32_t userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C2SQuitRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C2SQuitRoom) */ {
 public:
  inline C2SQuitRoom() : C2SQuitRoom(nullptr) {}
  ~C2SQuitRoom() override;
  explicit PROTOBUF_CONSTEXPR C2SQuitRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C2SQuitRoom(const C2SQuitRoom& from);
  C2SQuitRoom(C2SQuitRoom&& from) noexcept
    : C2SQuitRoom() {
    *this = ::std::move(from);
  }

  inline C2SQuitRoom& operator=(const C2SQuitRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline C2SQuitRoom& operator=(C2SQuitRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C2SQuitRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const C2SQuitRoom* internal_default_instance() {
    return reinterpret_cast<const C2SQuitRoom*>(
               &_C2SQuitRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(C2SQuitRoom& a, C2SQuitRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(C2SQuitRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C2SQuitRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C2SQuitRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C2SQuitRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C2SQuitRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C2SQuitRoom& from) {
    C2SQuitRoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C2SQuitRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C2SQuitRoom";
  }
  protected:
  explicit C2SQuitRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIDFieldNumber = 1,
    kUserIDFieldNumber = 2,
  };
  // int32 roomID = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // int32 userID = 2;
  void clear_userid();
  int32_t userid() const;
  void set_userid(int32_t value);
  private:
  int32_t _internal_userid() const;
  void _internal_set_userid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C2SQuitRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    int32_t userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class P_GameContent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.P_GameContent) */ {
 public:
  inline P_GameContent() : P_GameContent(nullptr) {}
  ~P_GameContent() override;
  explicit PROTOBUF_CONSTEXPR P_GameContent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  P_GameContent(const P_GameContent& from);
  P_GameContent(P_GameContent&& from) noexcept
    : P_GameContent() {
    *this = ::std::move(from);
  }

  inline P_GameContent& operator=(const P_GameContent& from) {
    CopyFrom(from);
    return *this;
  }
  inline P_GameContent& operator=(P_GameContent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const P_GameContent& default_instance() {
    return *internal_default_instance();
  }
  static inline const P_GameContent* internal_default_instance() {
    return reinterpret_cast<const P_GameContent*>(
               &_P_GameContent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(P_GameContent& a, P_GameContent& b) {
    a.Swap(&b);
  }
  inline void Swap(P_GameContent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(P_GameContent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  P_GameContent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<P_GameContent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const P_GameContent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const P_GameContent& from) {
    P_GameContent::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(P_GameContent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.P_GameContent";
  }
  protected:
  explicit P_GameContent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIDFieldNumber = 1,
    kYPosFieldNumber = 2,
    kXPosFieldNumber = 3,
    kStoneColorFieldNumber = 4,
  };
  // int32 roomID = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // float yPos = 2;
  void clear_ypos();
  float ypos() const;
  void set_ypos(float value);
  private:
  float _internal_ypos() const;
  void _internal_set_ypos(float value);
  public:

  // float xPos = 3;
  void clear_xpos();
  float xpos() const;
  void set_xpos(float value);
  private:
  float _internal_xpos() const;
  void _internal_set_xpos(float value);
  public:

  // int32 stoneColor = 4;
  void clear_stonecolor();
  int32_t stonecolor() const;
  void set_stonecolor(int32_t value);
  private:
  int32_t _internal_stonecolor() const;
  void _internal_set_stonecolor(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.P_GameContent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    float ypos_;
    float xpos_;
    int32_t stonecolor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C2SLoginSuccess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C2SLoginSuccess) */ {
 public:
  inline C2SLoginSuccess() : C2SLoginSuccess(nullptr) {}
  ~C2SLoginSuccess() override;
  explicit PROTOBUF_CONSTEXPR C2SLoginSuccess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C2SLoginSuccess(const C2SLoginSuccess& from);
  C2SLoginSuccess(C2SLoginSuccess&& from) noexcept
    : C2SLoginSuccess() {
    *this = ::std::move(from);
  }

  inline C2SLoginSuccess& operator=(const C2SLoginSuccess& from) {
    CopyFrom(from);
    return *this;
  }
  inline C2SLoginSuccess& operator=(C2SLoginSuccess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C2SLoginSuccess& default_instance() {
    return *internal_default_instance();
  }
  static inline const C2SLoginSuccess* internal_default_instance() {
    return reinterpret_cast<const C2SLoginSuccess*>(
               &_C2SLoginSuccess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(C2SLoginSuccess& a, C2SLoginSuccess& b) {
    a.Swap(&b);
  }
  inline void Swap(C2SLoginSuccess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C2SLoginSuccess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C2SLoginSuccess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C2SLoginSuccess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C2SLoginSuccess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C2SLoginSuccess& from) {
    C2SLoginSuccess::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C2SLoginSuccess* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C2SLoginSuccess";
  }
  protected:
  explicit C2SLoginSuccess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 1,
    kUserIDFieldNumber = 2,
  };
  // string userName = 1;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // int32 userID = 2;
  void clear_userid();
  int32_t userid() const;
  void set_userid(int32_t value);
  private:
  int32_t _internal_userid() const;
  void _internal_set_userid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C2SLoginSuccess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    int32_t userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S2CEnterRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S2CEnterRoom) */ {
 public:
  inline S2CEnterRoom() : S2CEnterRoom(nullptr) {}
  ~S2CEnterRoom() override;
  explicit PROTOBUF_CONSTEXPR S2CEnterRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S2CEnterRoom(const S2CEnterRoom& from);
  S2CEnterRoom(S2CEnterRoom&& from) noexcept
    : S2CEnterRoom() {
    *this = ::std::move(from);
  }

  inline S2CEnterRoom& operator=(const S2CEnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S2CEnterRoom& operator=(S2CEnterRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S2CEnterRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S2CEnterRoom* internal_default_instance() {
    return reinterpret_cast<const S2CEnterRoom*>(
               &_S2CEnterRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(S2CEnterRoom& a, S2CEnterRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S2CEnterRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S2CEnterRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S2CEnterRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S2CEnterRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S2CEnterRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S2CEnterRoom& from) {
    S2CEnterRoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S2CEnterRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S2CEnterRoom";
  }
  protected:
  explicit S2CEnterRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .Protocol.P_Player players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::Protocol::P_Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::P_Player >*
      mutable_players();
  private:
  const ::Protocol::P_Player& _internal_players(int index) const;
  ::Protocol::P_Player* _internal_add_players();
  public:
  const ::Protocol::P_Player& players(int index) const;
  ::Protocol::P_Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::P_Player >&
      players() const;

  // @@protoc_insertion_point(class_scope:Protocol.S2CEnterRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::P_Player > players_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S2CWinner final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S2CWinner) */ {
 public:
  inline S2CWinner() : S2CWinner(nullptr) {}
  ~S2CWinner() override;
  explicit PROTOBUF_CONSTEXPR S2CWinner(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S2CWinner(const S2CWinner& from);
  S2CWinner(S2CWinner&& from) noexcept
    : S2CWinner() {
    *this = ::std::move(from);
  }

  inline S2CWinner& operator=(const S2CWinner& from) {
    CopyFrom(from);
    return *this;
  }
  inline S2CWinner& operator=(S2CWinner&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S2CWinner& default_instance() {
    return *internal_default_instance();
  }
  static inline const S2CWinner* internal_default_instance() {
    return reinterpret_cast<const S2CWinner*>(
               &_S2CWinner_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(S2CWinner& a, S2CWinner& b) {
    a.Swap(&b);
  }
  inline void Swap(S2CWinner* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S2CWinner* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S2CWinner* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S2CWinner>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S2CWinner& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S2CWinner& from) {
    S2CWinner::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S2CWinner* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S2CWinner";
  }
  protected:
  explicit S2CWinner(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoneColorFieldNumber = 1,
  };
  // int32 stoneColor = 1;
  void clear_stonecolor();
  int32_t stonecolor() const;
  void set_stonecolor(int32_t value);
  private:
  int32_t _internal_stonecolor() const;
  void _internal_set_stonecolor(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S2CWinner)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t stonecolor_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class C2SChatRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.C2SChatRoom) */ {
 public:
  inline C2SChatRoom() : C2SChatRoom(nullptr) {}
  ~C2SChatRoom() override;
  explicit PROTOBUF_CONSTEXPR C2SChatRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  C2SChatRoom(const C2SChatRoom& from);
  C2SChatRoom(C2SChatRoom&& from) noexcept
    : C2SChatRoom() {
    *this = ::std::move(from);
  }

  inline C2SChatRoom& operator=(const C2SChatRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline C2SChatRoom& operator=(C2SChatRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const C2SChatRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const C2SChatRoom* internal_default_instance() {
    return reinterpret_cast<const C2SChatRoom*>(
               &_C2SChatRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(C2SChatRoom& a, C2SChatRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(C2SChatRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(C2SChatRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  C2SChatRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<C2SChatRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const C2SChatRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const C2SChatRoom& from) {
    C2SChatRoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(C2SChatRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.C2SChatRoom";
  }
  protected:
  explicit C2SChatRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kSenderNameFieldNumber = 3,
    kRoomIDFieldNumber = 1,
  };
  // string content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string senderName = 3;
  void clear_sendername();
  const std::string& sendername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sendername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sendername();
  PROTOBUF_NODISCARD std::string* release_sendername();
  void set_allocated_sendername(std::string* sendername);
  private:
  const std::string& _internal_sendername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendername(const std::string& value);
  std::string* _internal_mutable_sendername();
  public:

  // int32 roomID = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.C2SChatRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendername_;
    int32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S2CChatRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S2CChatRoom) */ {
 public:
  inline S2CChatRoom() : S2CChatRoom(nullptr) {}
  ~S2CChatRoom() override;
  explicit PROTOBUF_CONSTEXPR S2CChatRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S2CChatRoom(const S2CChatRoom& from);
  S2CChatRoom(S2CChatRoom&& from) noexcept
    : S2CChatRoom() {
    *this = ::std::move(from);
  }

  inline S2CChatRoom& operator=(const S2CChatRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S2CChatRoom& operator=(S2CChatRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S2CChatRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S2CChatRoom* internal_default_instance() {
    return reinterpret_cast<const S2CChatRoom*>(
               &_S2CChatRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S2CChatRoom& a, S2CChatRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S2CChatRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S2CChatRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S2CChatRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S2CChatRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S2CChatRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S2CChatRoom& from) {
    S2CChatRoom::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S2CChatRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S2CChatRoom";
  }
  protected:
  explicit S2CChatRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 1,
    kSenderNameFieldNumber = 2,
  };
  // string content = 1;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string senderName = 2;
  void clear_sendername();
  const std::string& sendername() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sendername(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sendername();
  PROTOBUF_NODISCARD std::string* release_sendername();
  void set_allocated_sendername(std::string* sendername);
  private:
  const std::string& _internal_sendername() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sendername(const std::string& value);
  std::string* _internal_mutable_sendername();
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S2CChatRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sendername_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S2CBattleServerAddr final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S2CBattleServerAddr) */ {
 public:
  inline S2CBattleServerAddr() : S2CBattleServerAddr(nullptr) {}
  ~S2CBattleServerAddr() override;
  explicit PROTOBUF_CONSTEXPR S2CBattleServerAddr(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S2CBattleServerAddr(const S2CBattleServerAddr& from);
  S2CBattleServerAddr(S2CBattleServerAddr&& from) noexcept
    : S2CBattleServerAddr() {
    *this = ::std::move(from);
  }

  inline S2CBattleServerAddr& operator=(const S2CBattleServerAddr& from) {
    CopyFrom(from);
    return *this;
  }
  inline S2CBattleServerAddr& operator=(S2CBattleServerAddr&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S2CBattleServerAddr& default_instance() {
    return *internal_default_instance();
  }
  static inline const S2CBattleServerAddr* internal_default_instance() {
    return reinterpret_cast<const S2CBattleServerAddr*>(
               &_S2CBattleServerAddr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S2CBattleServerAddr& a, S2CBattleServerAddr& b) {
    a.Swap(&b);
  }
  inline void Swap(S2CBattleServerAddr* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S2CBattleServerAddr* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S2CBattleServerAddr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S2CBattleServerAddr>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S2CBattleServerAddr& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S2CBattleServerAddr& from) {
    S2CBattleServerAddr::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S2CBattleServerAddr* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S2CBattleServerAddr";
  }
  protected:
  explicit S2CBattleServerAddr(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBattleServerIpFieldNumber = 1,
    kPortFieldNumber = 2,
    kRoomIDFieldNumber = 3,
  };
  // string battleServerIp = 1;
  void clear_battleserverip();
  const std::string& battleserverip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_battleserverip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_battleserverip();
  PROTOBUF_NODISCARD std::string* release_battleserverip();
  void set_allocated_battleserverip(std::string* battleserverip);
  private:
  const std::string& _internal_battleserverip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_battleserverip(const std::string& value);
  std::string* _internal_mutable_battleserverip();
  public:

  // int32 port = 2;
  void clear_port();
  int32_t port() const;
  void set_port(int32_t value);
  private:
  int32_t _internal_port() const;
  void _internal_set_port(int32_t value);
  public:

  // int32 roomID = 3;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S2CBattleServerAddr)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr battleserverip_;
    int32_t port_;
    int32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S2CRoomID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S2CRoomID) */ {
 public:
  inline S2CRoomID() : S2CRoomID(nullptr) {}
  ~S2CRoomID() override;
  explicit PROTOBUF_CONSTEXPR S2CRoomID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S2CRoomID(const S2CRoomID& from);
  S2CRoomID(S2CRoomID&& from) noexcept
    : S2CRoomID() {
    *this = ::std::move(from);
  }

  inline S2CRoomID& operator=(const S2CRoomID& from) {
    CopyFrom(from);
    return *this;
  }
  inline S2CRoomID& operator=(S2CRoomID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S2CRoomID& default_instance() {
    return *internal_default_instance();
  }
  static inline const S2CRoomID* internal_default_instance() {
    return reinterpret_cast<const S2CRoomID*>(
               &_S2CRoomID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S2CRoomID& a, S2CRoomID& b) {
    a.Swap(&b);
  }
  inline void Swap(S2CRoomID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S2CRoomID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S2CRoomID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S2CRoomID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S2CRoomID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S2CRoomID& from) {
    S2CRoomID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S2CRoomID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S2CRoomID";
  }
  protected:
  explicit S2CRoomID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIDFieldNumber = 1,
  };
  // int32 roomID = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S2CRoomID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// -------------------------------------------------------------------

class S2CRoomCreated final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.S2CRoomCreated) */ {
 public:
  inline S2CRoomCreated() : S2CRoomCreated(nullptr) {}
  ~S2CRoomCreated() override;
  explicit PROTOBUF_CONSTEXPR S2CRoomCreated(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S2CRoomCreated(const S2CRoomCreated& from);
  S2CRoomCreated(S2CRoomCreated&& from) noexcept
    : S2CRoomCreated() {
    *this = ::std::move(from);
  }

  inline S2CRoomCreated& operator=(const S2CRoomCreated& from) {
    CopyFrom(from);
    return *this;
  }
  inline S2CRoomCreated& operator=(S2CRoomCreated&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S2CRoomCreated& default_instance() {
    return *internal_default_instance();
  }
  static inline const S2CRoomCreated* internal_default_instance() {
    return reinterpret_cast<const S2CRoomCreated*>(
               &_S2CRoomCreated_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S2CRoomCreated& a, S2CRoomCreated& b) {
    a.Swap(&b);
  }
  inline void Swap(S2CRoomCreated* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S2CRoomCreated* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S2CRoomCreated* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S2CRoomCreated>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S2CRoomCreated& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const S2CRoomCreated& from) {
    S2CRoomCreated::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S2CRoomCreated* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.S2CRoomCreated";
  }
  protected:
  explicit S2CRoomCreated(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomIDFieldNumber = 1,
  };
  // int32 roomID = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.S2CRoomCreated)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t roomid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_Protocol_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// P_Room

// int32 roomID = 1;
inline void P_Room::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t P_Room::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t P_Room::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.P_Room.roomID)
  return _internal_roomid();
}
inline void P_Room::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void P_Room::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.P_Room.roomID)
}

// string roomName = 2;
inline void P_Room::clear_roomname() {
  _impl_.roomname_.ClearToEmpty();
}
inline const std::string& P_Room::roomname() const {
  // @@protoc_insertion_point(field_get:Protocol.P_Room.roomName)
  return _internal_roomname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_Room::set_roomname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roomname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.P_Room.roomName)
}
inline std::string* P_Room::mutable_roomname() {
  std::string* _s = _internal_mutable_roomname();
  // @@protoc_insertion_point(field_mutable:Protocol.P_Room.roomName)
  return _s;
}
inline const std::string& P_Room::_internal_roomname() const {
  return _impl_.roomname_.Get();
}
inline void P_Room::_internal_set_roomname(const std::string& value) {
  
  _impl_.roomname_.Set(value, GetArenaForAllocation());
}
inline std::string* P_Room::_internal_mutable_roomname() {
  
  return _impl_.roomname_.Mutable(GetArenaForAllocation());
}
inline std::string* P_Room::release_roomname() {
  // @@protoc_insertion_point(field_release:Protocol.P_Room.roomName)
  return _impl_.roomname_.Release();
}
inline void P_Room::set_allocated_roomname(std::string* roomname) {
  if (roomname != nullptr) {
    
  } else {
    
  }
  _impl_.roomname_.SetAllocated(roomname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roomname_.IsDefault()) {
    _impl_.roomname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.P_Room.roomName)
}

// string hostName = 3;
inline void P_Room::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& P_Room::hostname() const {
  // @@protoc_insertion_point(field_get:Protocol.P_Room.hostName)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_Room::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.P_Room.hostName)
}
inline std::string* P_Room::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:Protocol.P_Room.hostName)
  return _s;
}
inline const std::string& P_Room::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void P_Room::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* P_Room::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* P_Room::release_hostname() {
  // @@protoc_insertion_point(field_release:Protocol.P_Room.hostName)
  return _impl_.hostname_.Release();
}
inline void P_Room::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.P_Room.hostName)
}

// int32 num_players = 4;
inline void P_Room::clear_num_players() {
  _impl_.num_players_ = 0;
}
inline int32_t P_Room::_internal_num_players() const {
  return _impl_.num_players_;
}
inline int32_t P_Room::num_players() const {
  // @@protoc_insertion_point(field_get:Protocol.P_Room.num_players)
  return _internal_num_players();
}
inline void P_Room::_internal_set_num_players(int32_t value) {
  
  _impl_.num_players_ = value;
}
inline void P_Room::set_num_players(int32_t value) {
  _internal_set_num_players(value);
  // @@protoc_insertion_point(field_set:Protocol.P_Room.num_players)
}

// -------------------------------------------------------------------

// P_Player

// string userName = 1;
inline void P_Player::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& P_Player::username() const {
  // @@protoc_insertion_point(field_get:Protocol.P_Player.userName)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void P_Player::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.P_Player.userName)
}
inline std::string* P_Player::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:Protocol.P_Player.userName)
  return _s;
}
inline const std::string& P_Player::_internal_username() const {
  return _impl_.username_.Get();
}
inline void P_Player::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* P_Player::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* P_Player::release_username() {
  // @@protoc_insertion_point(field_release:Protocol.P_Player.userName)
  return _impl_.username_.Release();
}
inline void P_Player::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.P_Player.userName)
}

// -------------------------------------------------------------------

// S2CRoomList

// repeated .Protocol.P_Room rooms = 1;
inline int S2CRoomList::_internal_rooms_size() const {
  return _impl_.rooms_.size();
}
inline int S2CRoomList::rooms_size() const {
  return _internal_rooms_size();
}
inline void S2CRoomList::clear_rooms() {
  _impl_.rooms_.Clear();
}
inline ::Protocol::P_Room* S2CRoomList::mutable_rooms(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S2CRoomList.rooms)
  return _impl_.rooms_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::P_Room >*
S2CRoomList::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S2CRoomList.rooms)
  return &_impl_.rooms_;
}
inline const ::Protocol::P_Room& S2CRoomList::_internal_rooms(int index) const {
  return _impl_.rooms_.Get(index);
}
inline const ::Protocol::P_Room& S2CRoomList::rooms(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S2CRoomList.rooms)
  return _internal_rooms(index);
}
inline ::Protocol::P_Room* S2CRoomList::_internal_add_rooms() {
  return _impl_.rooms_.Add();
}
inline ::Protocol::P_Room* S2CRoomList::add_rooms() {
  ::Protocol::P_Room* _add = _internal_add_rooms();
  // @@protoc_insertion_point(field_add:Protocol.S2CRoomList.rooms)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::P_Room >&
S2CRoomList::rooms() const {
  // @@protoc_insertion_point(field_list:Protocol.S2CRoomList.rooms)
  return _impl_.rooms_;
}

// -------------------------------------------------------------------

// C2SMakeRoom

// string roomName = 1;
inline void C2SMakeRoom::clear_roomname() {
  _impl_.roomname_.ClearToEmpty();
}
inline const std::string& C2SMakeRoom::roomname() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SMakeRoom.roomName)
  return _internal_roomname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C2SMakeRoom::set_roomname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.roomname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C2SMakeRoom.roomName)
}
inline std::string* C2SMakeRoom::mutable_roomname() {
  std::string* _s = _internal_mutable_roomname();
  // @@protoc_insertion_point(field_mutable:Protocol.C2SMakeRoom.roomName)
  return _s;
}
inline const std::string& C2SMakeRoom::_internal_roomname() const {
  return _impl_.roomname_.Get();
}
inline void C2SMakeRoom::_internal_set_roomname(const std::string& value) {
  
  _impl_.roomname_.Set(value, GetArenaForAllocation());
}
inline std::string* C2SMakeRoom::_internal_mutable_roomname() {
  
  return _impl_.roomname_.Mutable(GetArenaForAllocation());
}
inline std::string* C2SMakeRoom::release_roomname() {
  // @@protoc_insertion_point(field_release:Protocol.C2SMakeRoom.roomName)
  return _impl_.roomname_.Release();
}
inline void C2SMakeRoom::set_allocated_roomname(std::string* roomname) {
  if (roomname != nullptr) {
    
  } else {
    
  }
  _impl_.roomname_.SetAllocated(roomname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.roomname_.IsDefault()) {
    _impl_.roomname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C2SMakeRoom.roomName)
}

// string hostName = 2;
inline void C2SMakeRoom::clear_hostname() {
  _impl_.hostname_.ClearToEmpty();
}
inline const std::string& C2SMakeRoom::hostname() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SMakeRoom.hostName)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C2SMakeRoom::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 _impl_.hostname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C2SMakeRoom.hostName)
}
inline std::string* C2SMakeRoom::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:Protocol.C2SMakeRoom.hostName)
  return _s;
}
inline const std::string& C2SMakeRoom::_internal_hostname() const {
  return _impl_.hostname_.Get();
}
inline void C2SMakeRoom::_internal_set_hostname(const std::string& value) {
  
  _impl_.hostname_.Set(value, GetArenaForAllocation());
}
inline std::string* C2SMakeRoom::_internal_mutable_hostname() {
  
  return _impl_.hostname_.Mutable(GetArenaForAllocation());
}
inline std::string* C2SMakeRoom::release_hostname() {
  // @@protoc_insertion_point(field_release:Protocol.C2SMakeRoom.hostName)
  return _impl_.hostname_.Release();
}
inline void C2SMakeRoom::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  _impl_.hostname_.SetAllocated(hostname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.hostname_.IsDefault()) {
    _impl_.hostname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C2SMakeRoom.hostName)
}

// int32 num_players = 3;
inline void C2SMakeRoom::clear_num_players() {
  _impl_.num_players_ = 0;
}
inline int32_t C2SMakeRoom::_internal_num_players() const {
  return _impl_.num_players_;
}
inline int32_t C2SMakeRoom::num_players() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SMakeRoom.num_players)
  return _internal_num_players();
}
inline void C2SMakeRoom::_internal_set_num_players(int32_t value) {
  
  _impl_.num_players_ = value;
}
inline void C2SMakeRoom::set_num_players(int32_t value) {
  _internal_set_num_players(value);
  // @@protoc_insertion_point(field_set:Protocol.C2SMakeRoom.num_players)
}

// -------------------------------------------------------------------

// C2SEnterRoom

// int32 roomID = 1;
inline void C2SEnterRoom::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t C2SEnterRoom::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t C2SEnterRoom::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SEnterRoom.roomID)
  return _internal_roomid();
}
inline void C2SEnterRoom::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void C2SEnterRoom::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.C2SEnterRoom.roomID)
}

// int32 userID = 2;
inline void C2SEnterRoom::clear_userid() {
  _impl_.userid_ = 0;
}
inline int32_t C2SEnterRoom::_internal_userid() const {
  return _impl_.userid_;
}
inline int32_t C2SEnterRoom::userid() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SEnterRoom.userID)
  return _internal_userid();
}
inline void C2SEnterRoom::_internal_set_userid(int32_t value) {
  
  _impl_.userid_ = value;
}
inline void C2SEnterRoom::set_userid(int32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:Protocol.C2SEnterRoom.userID)
}

// -------------------------------------------------------------------

// C2SQuitRoom

// int32 roomID = 1;
inline void C2SQuitRoom::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t C2SQuitRoom::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t C2SQuitRoom::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SQuitRoom.roomID)
  return _internal_roomid();
}
inline void C2SQuitRoom::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void C2SQuitRoom::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.C2SQuitRoom.roomID)
}

// int32 userID = 2;
inline void C2SQuitRoom::clear_userid() {
  _impl_.userid_ = 0;
}
inline int32_t C2SQuitRoom::_internal_userid() const {
  return _impl_.userid_;
}
inline int32_t C2SQuitRoom::userid() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SQuitRoom.userID)
  return _internal_userid();
}
inline void C2SQuitRoom::_internal_set_userid(int32_t value) {
  
  _impl_.userid_ = value;
}
inline void C2SQuitRoom::set_userid(int32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:Protocol.C2SQuitRoom.userID)
}

// -------------------------------------------------------------------

// P_GameContent

// int32 roomID = 1;
inline void P_GameContent::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t P_GameContent::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t P_GameContent::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.P_GameContent.roomID)
  return _internal_roomid();
}
inline void P_GameContent::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void P_GameContent::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.P_GameContent.roomID)
}

// float yPos = 2;
inline void P_GameContent::clear_ypos() {
  _impl_.ypos_ = 0;
}
inline float P_GameContent::_internal_ypos() const {
  return _impl_.ypos_;
}
inline float P_GameContent::ypos() const {
  // @@protoc_insertion_point(field_get:Protocol.P_GameContent.yPos)
  return _internal_ypos();
}
inline void P_GameContent::_internal_set_ypos(float value) {
  
  _impl_.ypos_ = value;
}
inline void P_GameContent::set_ypos(float value) {
  _internal_set_ypos(value);
  // @@protoc_insertion_point(field_set:Protocol.P_GameContent.yPos)
}

// float xPos = 3;
inline void P_GameContent::clear_xpos() {
  _impl_.xpos_ = 0;
}
inline float P_GameContent::_internal_xpos() const {
  return _impl_.xpos_;
}
inline float P_GameContent::xpos() const {
  // @@protoc_insertion_point(field_get:Protocol.P_GameContent.xPos)
  return _internal_xpos();
}
inline void P_GameContent::_internal_set_xpos(float value) {
  
  _impl_.xpos_ = value;
}
inline void P_GameContent::set_xpos(float value) {
  _internal_set_xpos(value);
  // @@protoc_insertion_point(field_set:Protocol.P_GameContent.xPos)
}

// int32 stoneColor = 4;
inline void P_GameContent::clear_stonecolor() {
  _impl_.stonecolor_ = 0;
}
inline int32_t P_GameContent::_internal_stonecolor() const {
  return _impl_.stonecolor_;
}
inline int32_t P_GameContent::stonecolor() const {
  // @@protoc_insertion_point(field_get:Protocol.P_GameContent.stoneColor)
  return _internal_stonecolor();
}
inline void P_GameContent::_internal_set_stonecolor(int32_t value) {
  
  _impl_.stonecolor_ = value;
}
inline void P_GameContent::set_stonecolor(int32_t value) {
  _internal_set_stonecolor(value);
  // @@protoc_insertion_point(field_set:Protocol.P_GameContent.stoneColor)
}

// -------------------------------------------------------------------

// C2SLoginSuccess

// string userName = 1;
inline void C2SLoginSuccess::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& C2SLoginSuccess::username() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SLoginSuccess.userName)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C2SLoginSuccess::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C2SLoginSuccess.userName)
}
inline std::string* C2SLoginSuccess::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:Protocol.C2SLoginSuccess.userName)
  return _s;
}
inline const std::string& C2SLoginSuccess::_internal_username() const {
  return _impl_.username_.Get();
}
inline void C2SLoginSuccess::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* C2SLoginSuccess::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* C2SLoginSuccess::release_username() {
  // @@protoc_insertion_point(field_release:Protocol.C2SLoginSuccess.userName)
  return _impl_.username_.Release();
}
inline void C2SLoginSuccess::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C2SLoginSuccess.userName)
}

// int32 userID = 2;
inline void C2SLoginSuccess::clear_userid() {
  _impl_.userid_ = 0;
}
inline int32_t C2SLoginSuccess::_internal_userid() const {
  return _impl_.userid_;
}
inline int32_t C2SLoginSuccess::userid() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SLoginSuccess.userID)
  return _internal_userid();
}
inline void C2SLoginSuccess::_internal_set_userid(int32_t value) {
  
  _impl_.userid_ = value;
}
inline void C2SLoginSuccess::set_userid(int32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:Protocol.C2SLoginSuccess.userID)
}

// -------------------------------------------------------------------

// S2CEnterRoom

// repeated .Protocol.P_Player players = 1;
inline int S2CEnterRoom::_internal_players_size() const {
  return _impl_.players_.size();
}
inline int S2CEnterRoom::players_size() const {
  return _internal_players_size();
}
inline void S2CEnterRoom::clear_players() {
  _impl_.players_.Clear();
}
inline ::Protocol::P_Player* S2CEnterRoom::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.S2CEnterRoom.players)
  return _impl_.players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::P_Player >*
S2CEnterRoom::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.S2CEnterRoom.players)
  return &_impl_.players_;
}
inline const ::Protocol::P_Player& S2CEnterRoom::_internal_players(int index) const {
  return _impl_.players_.Get(index);
}
inline const ::Protocol::P_Player& S2CEnterRoom::players(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.S2CEnterRoom.players)
  return _internal_players(index);
}
inline ::Protocol::P_Player* S2CEnterRoom::_internal_add_players() {
  return _impl_.players_.Add();
}
inline ::Protocol::P_Player* S2CEnterRoom::add_players() {
  ::Protocol::P_Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:Protocol.S2CEnterRoom.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::P_Player >&
S2CEnterRoom::players() const {
  // @@protoc_insertion_point(field_list:Protocol.S2CEnterRoom.players)
  return _impl_.players_;
}

// -------------------------------------------------------------------

// S2CWinner

// int32 stoneColor = 1;
inline void S2CWinner::clear_stonecolor() {
  _impl_.stonecolor_ = 0;
}
inline int32_t S2CWinner::_internal_stonecolor() const {
  return _impl_.stonecolor_;
}
inline int32_t S2CWinner::stonecolor() const {
  // @@protoc_insertion_point(field_get:Protocol.S2CWinner.stoneColor)
  return _internal_stonecolor();
}
inline void S2CWinner::_internal_set_stonecolor(int32_t value) {
  
  _impl_.stonecolor_ = value;
}
inline void S2CWinner::set_stonecolor(int32_t value) {
  _internal_set_stonecolor(value);
  // @@protoc_insertion_point(field_set:Protocol.S2CWinner.stoneColor)
}

// -------------------------------------------------------------------

// C2SChatRoom

// int32 roomID = 1;
inline void C2SChatRoom::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t C2SChatRoom::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t C2SChatRoom::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SChatRoom.roomID)
  return _internal_roomid();
}
inline void C2SChatRoom::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void C2SChatRoom::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.C2SChatRoom.roomID)
}

// string content = 2;
inline void C2SChatRoom::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& C2SChatRoom::content() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SChatRoom.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C2SChatRoom::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C2SChatRoom.content)
}
inline std::string* C2SChatRoom::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:Protocol.C2SChatRoom.content)
  return _s;
}
inline const std::string& C2SChatRoom::_internal_content() const {
  return _impl_.content_.Get();
}
inline void C2SChatRoom::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* C2SChatRoom::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* C2SChatRoom::release_content() {
  // @@protoc_insertion_point(field_release:Protocol.C2SChatRoom.content)
  return _impl_.content_.Release();
}
inline void C2SChatRoom::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C2SChatRoom.content)
}

// string senderName = 3;
inline void C2SChatRoom::clear_sendername() {
  _impl_.sendername_.ClearToEmpty();
}
inline const std::string& C2SChatRoom::sendername() const {
  // @@protoc_insertion_point(field_get:Protocol.C2SChatRoom.senderName)
  return _internal_sendername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void C2SChatRoom::set_sendername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sendername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.C2SChatRoom.senderName)
}
inline std::string* C2SChatRoom::mutable_sendername() {
  std::string* _s = _internal_mutable_sendername();
  // @@protoc_insertion_point(field_mutable:Protocol.C2SChatRoom.senderName)
  return _s;
}
inline const std::string& C2SChatRoom::_internal_sendername() const {
  return _impl_.sendername_.Get();
}
inline void C2SChatRoom::_internal_set_sendername(const std::string& value) {
  
  _impl_.sendername_.Set(value, GetArenaForAllocation());
}
inline std::string* C2SChatRoom::_internal_mutable_sendername() {
  
  return _impl_.sendername_.Mutable(GetArenaForAllocation());
}
inline std::string* C2SChatRoom::release_sendername() {
  // @@protoc_insertion_point(field_release:Protocol.C2SChatRoom.senderName)
  return _impl_.sendername_.Release();
}
inline void C2SChatRoom::set_allocated_sendername(std::string* sendername) {
  if (sendername != nullptr) {
    
  } else {
    
  }
  _impl_.sendername_.SetAllocated(sendername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sendername_.IsDefault()) {
    _impl_.sendername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.C2SChatRoom.senderName)
}

// -------------------------------------------------------------------

// S2CChatRoom

// string content = 1;
inline void S2CChatRoom::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& S2CChatRoom::content() const {
  // @@protoc_insertion_point(field_get:Protocol.S2CChatRoom.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S2CChatRoom::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S2CChatRoom.content)
}
inline std::string* S2CChatRoom::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:Protocol.S2CChatRoom.content)
  return _s;
}
inline const std::string& S2CChatRoom::_internal_content() const {
  return _impl_.content_.Get();
}
inline void S2CChatRoom::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* S2CChatRoom::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* S2CChatRoom::release_content() {
  // @@protoc_insertion_point(field_release:Protocol.S2CChatRoom.content)
  return _impl_.content_.Release();
}
inline void S2CChatRoom::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S2CChatRoom.content)
}

// string senderName = 2;
inline void S2CChatRoom::clear_sendername() {
  _impl_.sendername_.ClearToEmpty();
}
inline const std::string& S2CChatRoom::sendername() const {
  // @@protoc_insertion_point(field_get:Protocol.S2CChatRoom.senderName)
  return _internal_sendername();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S2CChatRoom::set_sendername(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sendername_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S2CChatRoom.senderName)
}
inline std::string* S2CChatRoom::mutable_sendername() {
  std::string* _s = _internal_mutable_sendername();
  // @@protoc_insertion_point(field_mutable:Protocol.S2CChatRoom.senderName)
  return _s;
}
inline const std::string& S2CChatRoom::_internal_sendername() const {
  return _impl_.sendername_.Get();
}
inline void S2CChatRoom::_internal_set_sendername(const std::string& value) {
  
  _impl_.sendername_.Set(value, GetArenaForAllocation());
}
inline std::string* S2CChatRoom::_internal_mutable_sendername() {
  
  return _impl_.sendername_.Mutable(GetArenaForAllocation());
}
inline std::string* S2CChatRoom::release_sendername() {
  // @@protoc_insertion_point(field_release:Protocol.S2CChatRoom.senderName)
  return _impl_.sendername_.Release();
}
inline void S2CChatRoom::set_allocated_sendername(std::string* sendername) {
  if (sendername != nullptr) {
    
  } else {
    
  }
  _impl_.sendername_.SetAllocated(sendername, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sendername_.IsDefault()) {
    _impl_.sendername_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S2CChatRoom.senderName)
}

// -------------------------------------------------------------------

// S2CBattleServerAddr

// string battleServerIp = 1;
inline void S2CBattleServerAddr::clear_battleserverip() {
  _impl_.battleserverip_.ClearToEmpty();
}
inline const std::string& S2CBattleServerAddr::battleserverip() const {
  // @@protoc_insertion_point(field_get:Protocol.S2CBattleServerAddr.battleServerIp)
  return _internal_battleserverip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void S2CBattleServerAddr::set_battleserverip(ArgT0&& arg0, ArgT... args) {
 
 _impl_.battleserverip_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.S2CBattleServerAddr.battleServerIp)
}
inline std::string* S2CBattleServerAddr::mutable_battleserverip() {
  std::string* _s = _internal_mutable_battleserverip();
  // @@protoc_insertion_point(field_mutable:Protocol.S2CBattleServerAddr.battleServerIp)
  return _s;
}
inline const std::string& S2CBattleServerAddr::_internal_battleserverip() const {
  return _impl_.battleserverip_.Get();
}
inline void S2CBattleServerAddr::_internal_set_battleserverip(const std::string& value) {
  
  _impl_.battleserverip_.Set(value, GetArenaForAllocation());
}
inline std::string* S2CBattleServerAddr::_internal_mutable_battleserverip() {
  
  return _impl_.battleserverip_.Mutable(GetArenaForAllocation());
}
inline std::string* S2CBattleServerAddr::release_battleserverip() {
  // @@protoc_insertion_point(field_release:Protocol.S2CBattleServerAddr.battleServerIp)
  return _impl_.battleserverip_.Release();
}
inline void S2CBattleServerAddr::set_allocated_battleserverip(std::string* battleserverip) {
  if (battleserverip != nullptr) {
    
  } else {
    
  }
  _impl_.battleserverip_.SetAllocated(battleserverip, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.battleserverip_.IsDefault()) {
    _impl_.battleserverip_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.S2CBattleServerAddr.battleServerIp)
}

// int32 port = 2;
inline void S2CBattleServerAddr::clear_port() {
  _impl_.port_ = 0;
}
inline int32_t S2CBattleServerAddr::_internal_port() const {
  return _impl_.port_;
}
inline int32_t S2CBattleServerAddr::port() const {
  // @@protoc_insertion_point(field_get:Protocol.S2CBattleServerAddr.port)
  return _internal_port();
}
inline void S2CBattleServerAddr::_internal_set_port(int32_t value) {
  
  _impl_.port_ = value;
}
inline void S2CBattleServerAddr::set_port(int32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:Protocol.S2CBattleServerAddr.port)
}

// int32 roomID = 3;
inline void S2CBattleServerAddr::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t S2CBattleServerAddr::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t S2CBattleServerAddr::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.S2CBattleServerAddr.roomID)
  return _internal_roomid();
}
inline void S2CBattleServerAddr::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void S2CBattleServerAddr::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.S2CBattleServerAddr.roomID)
}

// -------------------------------------------------------------------

// S2CRoomID

// int32 roomID = 1;
inline void S2CRoomID::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t S2CRoomID::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t S2CRoomID::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.S2CRoomID.roomID)
  return _internal_roomid();
}
inline void S2CRoomID::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void S2CRoomID::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.S2CRoomID.roomID)
}

// -------------------------------------------------------------------

// S2CRoomCreated

// int32 roomID = 1;
inline void S2CRoomCreated::clear_roomid() {
  _impl_.roomid_ = 0;
}
inline int32_t S2CRoomCreated::_internal_roomid() const {
  return _impl_.roomid_;
}
inline int32_t S2CRoomCreated::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.S2CRoomCreated.roomID)
  return _internal_roomid();
}
inline void S2CRoomCreated::_internal_set_roomid(int32_t value) {
  
  _impl_.roomid_ = value;
}
inline void S2CRoomCreated::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.S2CRoomCreated.roomID)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Protocol_2eproto
